/// <reference types="node" />
/// <reference types="node" />
import { Abort, Bug } from './error.js';
import { AbortSignal } from 'abort-controller';
import type { Writable } from 'node:stream';
export declare const genericConfigurationFileNames: {
    readonly yarn: {
        readonly lockfile: "yarn.lock";
    };
    readonly pnpm: {
        readonly lockfile: "pnpm-lock.yaml";
    };
};
export declare const dependencyManager: readonly ["yarn", "npm", "pnpm"];
export declare type DependencyManager = typeof dependencyManager[number];
export declare const PackageJsonNotFoundError: (directory: string) => Abort;
export declare const FindUpAndReadPackageJsonNotFoundError: (directory: string) => Bug;
/**
 * Returns the dependency manager used to run the create workflow.
 * @param env {Object} The environment variables of the process in which the CLI runs.
 * @returns The dependency manager
 */
export declare function dependencyManagerUsedForCreating(env?: NodeJS.ProcessEnv): DependencyManager;
/**
 * Returns the dependency manager used by an existing project.
 * @param directory {string} The root directory of the project.
 * @returns The dependency manager
 */
export declare function getDependencyManager(directory: string): Promise<DependencyManager>;
interface InstallNPMDependenciesRecursivelyOptions {
    /**
     * The dependency manager to use to install the dependencies.
     */
    dependencyManager: DependencyManager;
    /**
     * The directory from where we'll find package.json's recursively
     */
    directory: string;
    /**
     * Specifies the maximum depth of the glob search.
     */
    deep?: number;
}
/**
 * This function traverses down a directory tree to find directories containing a package.json
 * and installs the dependencies if needed. To know if it's needed, it uses the "check" command
 * provided by dependency managers.
 * @param options {InstallNPMDependenciesRecursivelyOptions} Options to install dependencies recursively.
 */
export declare function installNPMDependenciesRecursively(options: InstallNPMDependenciesRecursivelyOptions): Promise<void>;
/**
 * Installs the dependencies in the given directory.
 * @param directory {string} The directory that contains the package.json
 * @param dependencyManager {DependencyManager} The dependency manager to use to install the dependencies.
 * @param stdout {Writable} Standard output stream.
 * @param stderr {Writable} Standard error stream.
 * @param signal {AbortSignal} Abort signal.
 * @returns stderr {Writable} Standard error stream.
 */
export declare function install(directory: string, dependencyManager: DependencyManager, stdout?: Writable, stderr?: Writable, signal?: AbortSignal): Promise<void>;
/**
 * Returns the name of the package configured in its package.json
 * @param packageJsonPath {string} Path to the package.json file
 * @returns A promise that resolves with the name.
 */
export declare function getPackageName(packageJsonPath: string): Promise<string>;
/**
 * Returns the list of production and dev dependencies of a package.json
 * @param packageJsonPath {string} Path to the package.json file
 * @returns A promise that resolves with the list of dependencies.
 */
export declare function getDependencies(packageJsonPath: string): Promise<{
    [key: string]: string;
}>;
export declare function checkForNewVersion(dependency: string, currentVersion: string): Promise<string | undefined>;
export declare function getOutputUpdateCLIReminder(dependencyManager: DependencyManager, version: string): string;
interface PackageJSONContents {
    name: string;
    version?: string;
    dependencies?: {
        [key: string]: string;
    };
    devDependencies?: {
        [key: string]: string;
    };
}
export declare function packageJSONContents(packageJsonPath: string): Promise<PackageJSONContents>;
export declare type DependencyType = 'dev' | 'prod' | 'peer';
interface AddNPMDependenciesIfNeededOptions {
    /** How dependencies should be added */
    type: DependencyType;
    /** The dependency manager to use to add dependencies */
    dependencyManager: DependencyManager;
    /** The directory that contains the package.json where dependencies will be added */
    directory: string;
    /** Standard output coming from the underlying installation process */
    stdout?: Writable;
    /** Standard error coming from the underlying installation process */
    stderr?: Writable;
    /** Abort signal to stop the process */
    signal?: AbortSignal;
}
export interface DependencyVersion {
    name: string;
    version: string | undefined;
}
/**
 * Adds dependencies to a Node project (i.e. a project that has a package.json)
 * @param dependencies {string[]} List of dependencies to be added.
 * @param options {AddNPMDependenciesIfNeededOptions} Options for adding dependencies.
 */
export declare function addNPMDependenciesIfNeeded(dependencies: DependencyVersion[], options: AddNPMDependenciesIfNeededOptions, force?: boolean): Promise<void>;
export declare function addNPMDependenciesWithoutVersionIfNeeded(dependencies: string[], options: AddNPMDependenciesIfNeededOptions): Promise<void>;
export declare function addLatestNPMDependencies(dependencies: string[], options: AddNPMDependenciesIfNeededOptions): Promise<void>;
export declare type ProjectType = 'node' | 'php' | 'ruby' | undefined;
export declare function getProjectType(directory: string): Promise<ProjectType>;
/**
 * Given a directory it traverses the directory up looking for a package.json and if found, it reads it
 * decodes the JSON, and returns its content as a Javascript object.
 * @param options {string} The directory from which traverse up.
 * @returns {Promise<{path: string; content: unknown}>} If found, the promise resolves with the path to the
 *  package.json and its content. If not found, it throws a FindUpAndReadPackageJsonNotFoundError error.
 */
export declare function findUpAndReadPackageJson(fromDirectory: string): Promise<{
    path: string;
    content: unknown;
}>;
export {};
