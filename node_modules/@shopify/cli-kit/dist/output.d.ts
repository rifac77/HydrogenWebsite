/// <reference types="node" />
import { Fatal } from './error.js';
import { DependencyManager } from './dependency.js';
import { AbortSignal } from 'abort-controller';
import { Writable } from 'node:stream';
export declare function initiateLogging({ logDir, filename, }: {
    logDir?: string;
    filename?: string;
}): void;
declare enum ContentTokenType {
    Raw = 0,
    Command = 1,
    Json = 2,
    Path = 3,
    Link = 4,
    Heading = 5,
    SubHeading = 6,
    Italic = 7,
    ErrorText = 8,
    Yellow = 9,
    Cyan = 10,
    Magenta = 11,
    Green = 12
}
interface ContentMetadata {
    link?: string;
}
declare class ContentToken {
    type: ContentTokenType;
    value: Message;
    metadata: ContentMetadata;
    constructor(value: Message, metadata: ContentMetadata | undefined, type: ContentTokenType);
}
export declare const token: {
    raw: (value: Message) => ContentToken;
    genericShellCommand: (value: Message) => ContentToken;
    json: (value: any) => ContentToken;
    path: (value: Message) => ContentToken;
    link: (value: Message, link: string) => ContentToken;
    heading: (value: Message) => ContentToken;
    subheading: (value: Message) => ContentToken;
    italic: (value: Message) => ContentToken;
    errorText: (value: Message) => ContentToken;
    cyan: (value: Message) => ContentToken;
    yellow: (value: Message) => ContentToken;
    magenta: (value: Message) => ContentToken;
    green: (value: Message) => ContentToken;
    packagejsonScript: (dependencyManager: DependencyManager, scriptName: string, ...scriptArgs: string[]) => ContentToken;
    successIcon: () => ContentToken;
    failIcon: () => ContentToken;
};
export declare class TokenizedString {
    value: string;
    constructor(value: string);
}
export declare type Message = string | TokenizedString;
export declare function content(strings: TemplateStringsArray, ...keys: (ContentToken | string)[]): TokenizedString;
/** Log levels */
export declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'silent';
/**
 *
 * @returns {LogLevel} It returns the log level set by the user.
 */
export declare const currentLogLevel: () => LogLevel;
export declare const shouldOutput: (logLevel: LogLevel) => boolean;
export declare let collectedLogs: {
    [key: string]: string[];
};
export declare const clearCollectedLogs: () => void;
/**
 * Ouputs information to the user. This is akin to "console.log"
 * Info messages don't get additional formatting.
 * Note: Info messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
export declare const info: (content: Message) => void;
/**
 * Outputs a success message to the user.
 * Success message receive a special formatting to make them stand out in the console.
 * Note: Success messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
export declare const success: (content: Message) => void;
/**
 * Outputs a completed message to the user.
 * Completed message receive a special formatting to make them stand out in the console.
 * Note: Completed messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
export declare const completed: (content: Message) => void;
/**
 * Ouputs debug information to the user. By default these output is hidden unless the user calls the CLI with --verbose.
 * Debug messages don't get additional formatting.
 * Note: Debug messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
export declare const debug: (content: Message) => void;
/**
 * Outputs a warning message to the user.
 * Warning messages receive a special formatting to make them stand out in the console.
 * Note: Warning messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
export declare const warn: (content: Message) => void;
/**
 * Prints a new line in the terminal.
 */
export declare const newline: () => void;
/**
 * Formats and outputs a fatal error.
 * Note: This API is not intended to be used internally. If you want to
 * abort the execution due to an error, raise a fatal error and let the
 * error handler handle and format it.
 * @param content {Fatal} The fatal error to be output.
 */
export declare const error: (content: Fatal) => Promise<void>;
export declare function stringifyMessage(message: Message): string;
export interface OutputProcess {
    /** The prefix to include in the logs
     *   [vite] Output coming from Vite
     */
    prefix: string;
    /**
     * A callback to invoke the process. stdout and stderr should be used
     * to send standard output and error data that gets formatted with the
     * right prefix.
     */
    action: (stdout: Writable, stderr: Writable, signal: AbortSignal) => Promise<void>;
}
/**
 * Use this function when you have multiple concurrent processes that send data events
 * and we need to output them ensuring that they can visually differenciated by the user.
 *
 * @param processes {OutputProcess[]} A list of processes to run concurrently.
 */
export declare function concurrent(processes: OutputProcess[], callback?: ((signal: AbortSignal) => void) | undefined): Promise<void>;
export declare function logFileExists(): boolean;
export declare function logToFile(message: string, logLevel: string): void;
export declare function unstyled(message: string): string;
export declare function shouldDisplayColors(): boolean;
export declare function pageLogs(): Promise<void>;
export {};
