import { stringifyMessage, error as outputError } from './output.js';
import { Errors } from '@oclif/core';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import sourceMapSupport from 'source-map-support';
export { ExtendableError } from 'ts-error';
export { AbortSignal } from 'abort-controller';
sourceMapSupport.install();
var FatalErrorType;
(function (FatalErrorType) {
    FatalErrorType[FatalErrorType["Abort"] = 0] = "Abort";
    FatalErrorType[FatalErrorType["AbortSilent"] = 1] = "AbortSilent";
    FatalErrorType[FatalErrorType["Bug"] = 2] = "Bug";
})(FatalErrorType || (FatalErrorType = {}));
export class CancelExecution extends Error {
}
/**
 * A fatal error represents an error shouldn't be rescued and that causes the execution to terminate.
 * There shouldn't be code that catches fatal errors.
 */
export class Fatal extends Error {
    constructor(message, type, tryMessage = null) {
        super(stringifyMessage(message));
        this.tryMessage = tryMessage ? stringifyMessage(tryMessage) : null;
        this.type = type;
    }
}
/**
 * An abort error is a fatal error that shouldn't be reported as a bug.
 * Those usually represent unexpected scenarios that we can't handle and that usually require some action from the developer
 */
export class Abort extends Fatal {
    constructor(message, tryMessage = null) {
        super(message, FatalErrorType.Abort, tryMessage);
    }
}
export class AbortSilent extends Fatal {
    constructor() {
        super('', FatalErrorType.AbortSilent);
    }
}
/**
 * A bug error is an error that represents a bug and therefore should be reported.
 */
export class Bug extends Fatal {
    constructor(message, tryMessage = null) {
        super(message, FatalErrorType.Bug, tryMessage);
    }
}
/**
 * A function that handles errors that blow up in the CLI.
 * @param error Error to be handled.
 * @returns A promise that resolves with the error passed.
 */
export async function handler(error) {
    let fatal;
    if (isFatal(error)) {
        fatal = error;
    }
    else {
        fatal = new Bug(error.message);
    }
    if (fatal.type === FatalErrorType.Bug) {
        fatal.stack = error.stack;
    }
    await outputError(fatal);
    return Promise.resolve(error);
}
export function mapper(error) {
    if (error instanceof Errors.CLIError) {
        const mappedError = new Abort(error.message);
        mappedError.stack = error.stack;
        return Promise.resolve(mappedError);
    }
    else {
        return Promise.resolve(error);
    }
}
export function isFatal(error) {
    return Object.prototype.hasOwnProperty.call(error, 'type');
}
export function shouldReport(error) {
    if (!isFatal(error)) {
        return true;
    }
    if (error.type === FatalErrorType.Bug) {
        return true;
    }
    return false;
}
//# sourceMappingURL=error.js.map